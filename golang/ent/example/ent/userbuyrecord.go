// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"sqlent/ent/user"
	"sqlent/ent/userbuyrecord"
	"strings"

	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

// UserBuyRecord is the model entity for the UserBuyRecord schema.
type UserBuyRecord struct {
	config `json:"-"`
	// ID of the ent.
	// 订单id
	ID uuid.UUID `json:"id,omitempty"`
	// Power holds the value of the "power" field.
	// 每份算力(T)
	Power int `json:"power,omitempty"`
	// PowerNum holds the value of the "power_num" field.
	// 购买的分数
	PowerNum int `json:"power_num,omitempty"`
	// TotalPower holds the value of the "total_power" field.
	// 购买的总算力
	TotalPower float64 `json:"total_power,omitempty"`
	// TotalDay holds the value of the "total_day" field.
	// 合约的总天数
	TotalDay int `json:"total_day,omitempty"`
	// RemainDay holds the value of the "remain_day" field.
	// 合约剩余天数
	RemainDay int `json:"remain_day,omitempty"`
	// Node holds the value of the "node" field.
	// 节点号
	Node string `json:"node,omitempty"`
	// UsedUsdt holds the value of the "used_usdt" field.
	// 消费的usdt
	UsedUsdt float64 `json:"used_usdt,omitempty"`
	// BuyDate holds the value of the "buy_date" field.
	// 购买日期
	BuyDate string `json:"buy_date,omitempty"`
	// Created holds the value of the "created" field.
	Created int64 `json:"created,omitempty"`
	// Updated holds the value of the "updated" field.
	Updated int64 `json:"updated,omitempty"`
	// Deleted holds the value of the "deleted" field.
	Deleted int64 `json:"deleted,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the UserBuyRecordQuery when eager-loading is set.
	Edges   UserBuyRecordEdges `json:"edges"`
	user_id *int64
}

// UserBuyRecordEdges holds the relations/edges for other nodes in the graph.
type UserBuyRecordEdges struct {
	// Owner holds the value of the owner edge.
	Owner *User `json:"owner,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [1]bool
}

// OwnerOrErr returns the Owner value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e UserBuyRecordEdges) OwnerOrErr() (*User, error) {
	if e.loadedTypes[0] {
		if e.Owner == nil {
			// The edge owner was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: user.Label}
		}
		return e.Owner, nil
	}
	return nil, &NotLoadedError{edge: "owner"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*UserBuyRecord) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case userbuyrecord.FieldTotalPower, userbuyrecord.FieldUsedUsdt:
			values[i] = &sql.NullFloat64{}
		case userbuyrecord.FieldPower, userbuyrecord.FieldPowerNum, userbuyrecord.FieldTotalDay, userbuyrecord.FieldRemainDay, userbuyrecord.FieldCreated, userbuyrecord.FieldUpdated, userbuyrecord.FieldDeleted:
			values[i] = &sql.NullInt64{}
		case userbuyrecord.FieldNode, userbuyrecord.FieldBuyDate:
			values[i] = &sql.NullString{}
		case userbuyrecord.FieldID:
			values[i] = &uuid.UUID{}
		case userbuyrecord.ForeignKeys[0]: // user_id
			values[i] = &sql.NullInt64{}
		default:
			return nil, fmt.Errorf("unexpected column %q for type UserBuyRecord", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the UserBuyRecord fields.
func (ubr *UserBuyRecord) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case userbuyrecord.FieldID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value != nil {
				ubr.ID = *value
			}
		case userbuyrecord.FieldPower:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field power", values[i])
			} else if value.Valid {
				ubr.Power = int(value.Int64)
			}
		case userbuyrecord.FieldPowerNum:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field power_num", values[i])
			} else if value.Valid {
				ubr.PowerNum = int(value.Int64)
			}
		case userbuyrecord.FieldTotalPower:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field total_power", values[i])
			} else if value.Valid {
				ubr.TotalPower = value.Float64
			}
		case userbuyrecord.FieldTotalDay:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field total_day", values[i])
			} else if value.Valid {
				ubr.TotalDay = int(value.Int64)
			}
		case userbuyrecord.FieldRemainDay:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field remain_day", values[i])
			} else if value.Valid {
				ubr.RemainDay = int(value.Int64)
			}
		case userbuyrecord.FieldNode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field node", values[i])
			} else if value.Valid {
				ubr.Node = value.String
			}
		case userbuyrecord.FieldUsedUsdt:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field used_usdt", values[i])
			} else if value.Valid {
				ubr.UsedUsdt = value.Float64
			}
		case userbuyrecord.FieldBuyDate:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field buy_date", values[i])
			} else if value.Valid {
				ubr.BuyDate = value.String
			}
		case userbuyrecord.FieldCreated:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field created", values[i])
			} else if value.Valid {
				ubr.Created = value.Int64
			}
		case userbuyrecord.FieldUpdated:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field updated", values[i])
			} else if value.Valid {
				ubr.Updated = value.Int64
			}
		case userbuyrecord.FieldDeleted:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field deleted", values[i])
			} else if value.Valid {
				ubr.Deleted = value.Int64
			}
		case userbuyrecord.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for edge-field user_id", value)
			} else if value.Valid {
				ubr.user_id = new(int64)
				*ubr.user_id = int64(value.Int64)
			}
		}
	}
	return nil
}

// QueryOwner queries the "owner" edge of the UserBuyRecord entity.
func (ubr *UserBuyRecord) QueryOwner() *UserQuery {
	return (&UserBuyRecordClient{config: ubr.config}).QueryOwner(ubr)
}

// Update returns a builder for updating this UserBuyRecord.
// Note that you need to call UserBuyRecord.Unwrap() before calling this method if this UserBuyRecord
// was returned from a transaction, and the transaction was committed or rolled back.
func (ubr *UserBuyRecord) Update() *UserBuyRecordUpdateOne {
	return (&UserBuyRecordClient{config: ubr.config}).UpdateOne(ubr)
}

// Unwrap unwraps the UserBuyRecord entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (ubr *UserBuyRecord) Unwrap() *UserBuyRecord {
	tx, ok := ubr.config.driver.(*txDriver)
	if !ok {
		panic("ent: UserBuyRecord is not a transactional entity")
	}
	ubr.config.driver = tx.drv
	return ubr
}

// String implements the fmt.Stringer.
func (ubr *UserBuyRecord) String() string {
	var builder strings.Builder
	builder.WriteString("UserBuyRecord(")
	builder.WriteString(fmt.Sprintf("id=%v", ubr.ID))
	builder.WriteString(", power=")
	builder.WriteString(fmt.Sprintf("%v", ubr.Power))
	builder.WriteString(", power_num=")
	builder.WriteString(fmt.Sprintf("%v", ubr.PowerNum))
	builder.WriteString(", total_power=")
	builder.WriteString(fmt.Sprintf("%v", ubr.TotalPower))
	builder.WriteString(", total_day=")
	builder.WriteString(fmt.Sprintf("%v", ubr.TotalDay))
	builder.WriteString(", remain_day=")
	builder.WriteString(fmt.Sprintf("%v", ubr.RemainDay))
	builder.WriteString(", node=")
	builder.WriteString(ubr.Node)
	builder.WriteString(", used_usdt=")
	builder.WriteString(fmt.Sprintf("%v", ubr.UsedUsdt))
	builder.WriteString(", buy_date=")
	builder.WriteString(ubr.BuyDate)
	builder.WriteString(", created=")
	builder.WriteString(fmt.Sprintf("%v", ubr.Created))
	builder.WriteString(", updated=")
	builder.WriteString(fmt.Sprintf("%v", ubr.Updated))
	builder.WriteString(", deleted=")
	builder.WriteString(fmt.Sprintf("%v", ubr.Deleted))
	builder.WriteByte(')')
	return builder.String()
}

// UserBuyRecords is a parsable slice of UserBuyRecord.
type UserBuyRecords []*UserBuyRecord

func (ubr UserBuyRecords) config(cfg config) {
	for _i := range ubr {
		ubr[_i].config = cfg
	}
}
