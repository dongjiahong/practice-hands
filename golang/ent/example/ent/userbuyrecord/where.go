// Code generated by entc, DO NOT EDIT.

package userbuyrecord

import (
	"sqlent/ent/predicate"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/google/uuid"
)

// ID filters vertices based on their ID field.
func ID(id uuid.UUID) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id uuid.UUID) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id uuid.UUID) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...uuid.UUID) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...uuid.UUID) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id uuid.UUID) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id uuid.UUID) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id uuid.UUID) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id uuid.UUID) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// Power applies equality check predicate on the "power" field. It's identical to PowerEQ.
func Power(v int) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPower), v))
	})
}

// PowerNum applies equality check predicate on the "power_num" field. It's identical to PowerNumEQ.
func PowerNum(v int) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPowerNum), v))
	})
}

// TotalPower applies equality check predicate on the "total_power" field. It's identical to TotalPowerEQ.
func TotalPower(v float64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTotalPower), v))
	})
}

// TotalDay applies equality check predicate on the "total_day" field. It's identical to TotalDayEQ.
func TotalDay(v int) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTotalDay), v))
	})
}

// RemainDay applies equality check predicate on the "remain_day" field. It's identical to RemainDayEQ.
func RemainDay(v int) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRemainDay), v))
	})
}

// Node applies equality check predicate on the "node" field. It's identical to NodeEQ.
func Node(v string) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldNode), v))
	})
}

// UsedUsdt applies equality check predicate on the "used_usdt" field. It's identical to UsedUsdtEQ.
func UsedUsdt(v float64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUsedUsdt), v))
	})
}

// BuyDate applies equality check predicate on the "buy_date" field. It's identical to BuyDateEQ.
func BuyDate(v string) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBuyDate), v))
	})
}

// Created applies equality check predicate on the "created" field. It's identical to CreatedEQ.
func Created(v int64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreated), v))
	})
}

// Updated applies equality check predicate on the "updated" field. It's identical to UpdatedEQ.
func Updated(v int64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdated), v))
	})
}

// Deleted applies equality check predicate on the "deleted" field. It's identical to DeletedEQ.
func Deleted(v int64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDeleted), v))
	})
}

// PowerEQ applies the EQ predicate on the "power" field.
func PowerEQ(v int) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPower), v))
	})
}

// PowerNEQ applies the NEQ predicate on the "power" field.
func PowerNEQ(v int) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPower), v))
	})
}

// PowerIn applies the In predicate on the "power" field.
func PowerIn(vs ...int) predicate.UserBuyRecord {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPower), v...))
	})
}

// PowerNotIn applies the NotIn predicate on the "power" field.
func PowerNotIn(vs ...int) predicate.UserBuyRecord {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPower), v...))
	})
}

// PowerGT applies the GT predicate on the "power" field.
func PowerGT(v int) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPower), v))
	})
}

// PowerGTE applies the GTE predicate on the "power" field.
func PowerGTE(v int) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPower), v))
	})
}

// PowerLT applies the LT predicate on the "power" field.
func PowerLT(v int) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPower), v))
	})
}

// PowerLTE applies the LTE predicate on the "power" field.
func PowerLTE(v int) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPower), v))
	})
}

// PowerNumEQ applies the EQ predicate on the "power_num" field.
func PowerNumEQ(v int) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPowerNum), v))
	})
}

// PowerNumNEQ applies the NEQ predicate on the "power_num" field.
func PowerNumNEQ(v int) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPowerNum), v))
	})
}

// PowerNumIn applies the In predicate on the "power_num" field.
func PowerNumIn(vs ...int) predicate.UserBuyRecord {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPowerNum), v...))
	})
}

// PowerNumNotIn applies the NotIn predicate on the "power_num" field.
func PowerNumNotIn(vs ...int) predicate.UserBuyRecord {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPowerNum), v...))
	})
}

// PowerNumGT applies the GT predicate on the "power_num" field.
func PowerNumGT(v int) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPowerNum), v))
	})
}

// PowerNumGTE applies the GTE predicate on the "power_num" field.
func PowerNumGTE(v int) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPowerNum), v))
	})
}

// PowerNumLT applies the LT predicate on the "power_num" field.
func PowerNumLT(v int) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPowerNum), v))
	})
}

// PowerNumLTE applies the LTE predicate on the "power_num" field.
func PowerNumLTE(v int) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPowerNum), v))
	})
}

// TotalPowerEQ applies the EQ predicate on the "total_power" field.
func TotalPowerEQ(v float64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTotalPower), v))
	})
}

// TotalPowerNEQ applies the NEQ predicate on the "total_power" field.
func TotalPowerNEQ(v float64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTotalPower), v))
	})
}

// TotalPowerIn applies the In predicate on the "total_power" field.
func TotalPowerIn(vs ...float64) predicate.UserBuyRecord {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTotalPower), v...))
	})
}

// TotalPowerNotIn applies the NotIn predicate on the "total_power" field.
func TotalPowerNotIn(vs ...float64) predicate.UserBuyRecord {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTotalPower), v...))
	})
}

// TotalPowerGT applies the GT predicate on the "total_power" field.
func TotalPowerGT(v float64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTotalPower), v))
	})
}

// TotalPowerGTE applies the GTE predicate on the "total_power" field.
func TotalPowerGTE(v float64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTotalPower), v))
	})
}

// TotalPowerLT applies the LT predicate on the "total_power" field.
func TotalPowerLT(v float64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTotalPower), v))
	})
}

// TotalPowerLTE applies the LTE predicate on the "total_power" field.
func TotalPowerLTE(v float64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTotalPower), v))
	})
}

// TotalDayEQ applies the EQ predicate on the "total_day" field.
func TotalDayEQ(v int) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTotalDay), v))
	})
}

// TotalDayNEQ applies the NEQ predicate on the "total_day" field.
func TotalDayNEQ(v int) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTotalDay), v))
	})
}

// TotalDayIn applies the In predicate on the "total_day" field.
func TotalDayIn(vs ...int) predicate.UserBuyRecord {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTotalDay), v...))
	})
}

// TotalDayNotIn applies the NotIn predicate on the "total_day" field.
func TotalDayNotIn(vs ...int) predicate.UserBuyRecord {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTotalDay), v...))
	})
}

// TotalDayGT applies the GT predicate on the "total_day" field.
func TotalDayGT(v int) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTotalDay), v))
	})
}

// TotalDayGTE applies the GTE predicate on the "total_day" field.
func TotalDayGTE(v int) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTotalDay), v))
	})
}

// TotalDayLT applies the LT predicate on the "total_day" field.
func TotalDayLT(v int) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTotalDay), v))
	})
}

// TotalDayLTE applies the LTE predicate on the "total_day" field.
func TotalDayLTE(v int) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTotalDay), v))
	})
}

// RemainDayEQ applies the EQ predicate on the "remain_day" field.
func RemainDayEQ(v int) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRemainDay), v))
	})
}

// RemainDayNEQ applies the NEQ predicate on the "remain_day" field.
func RemainDayNEQ(v int) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRemainDay), v))
	})
}

// RemainDayIn applies the In predicate on the "remain_day" field.
func RemainDayIn(vs ...int) predicate.UserBuyRecord {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRemainDay), v...))
	})
}

// RemainDayNotIn applies the NotIn predicate on the "remain_day" field.
func RemainDayNotIn(vs ...int) predicate.UserBuyRecord {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRemainDay), v...))
	})
}

// RemainDayGT applies the GT predicate on the "remain_day" field.
func RemainDayGT(v int) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldRemainDay), v))
	})
}

// RemainDayGTE applies the GTE predicate on the "remain_day" field.
func RemainDayGTE(v int) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldRemainDay), v))
	})
}

// RemainDayLT applies the LT predicate on the "remain_day" field.
func RemainDayLT(v int) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldRemainDay), v))
	})
}

// RemainDayLTE applies the LTE predicate on the "remain_day" field.
func RemainDayLTE(v int) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldRemainDay), v))
	})
}

// NodeEQ applies the EQ predicate on the "node" field.
func NodeEQ(v string) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldNode), v))
	})
}

// NodeNEQ applies the NEQ predicate on the "node" field.
func NodeNEQ(v string) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldNode), v))
	})
}

// NodeIn applies the In predicate on the "node" field.
func NodeIn(vs ...string) predicate.UserBuyRecord {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldNode), v...))
	})
}

// NodeNotIn applies the NotIn predicate on the "node" field.
func NodeNotIn(vs ...string) predicate.UserBuyRecord {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldNode), v...))
	})
}

// NodeGT applies the GT predicate on the "node" field.
func NodeGT(v string) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldNode), v))
	})
}

// NodeGTE applies the GTE predicate on the "node" field.
func NodeGTE(v string) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldNode), v))
	})
}

// NodeLT applies the LT predicate on the "node" field.
func NodeLT(v string) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldNode), v))
	})
}

// NodeLTE applies the LTE predicate on the "node" field.
func NodeLTE(v string) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldNode), v))
	})
}

// NodeContains applies the Contains predicate on the "node" field.
func NodeContains(v string) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldNode), v))
	})
}

// NodeHasPrefix applies the HasPrefix predicate on the "node" field.
func NodeHasPrefix(v string) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldNode), v))
	})
}

// NodeHasSuffix applies the HasSuffix predicate on the "node" field.
func NodeHasSuffix(v string) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldNode), v))
	})
}

// NodeEqualFold applies the EqualFold predicate on the "node" field.
func NodeEqualFold(v string) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldNode), v))
	})
}

// NodeContainsFold applies the ContainsFold predicate on the "node" field.
func NodeContainsFold(v string) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldNode), v))
	})
}

// UsedUsdtEQ applies the EQ predicate on the "used_usdt" field.
func UsedUsdtEQ(v float64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUsedUsdt), v))
	})
}

// UsedUsdtNEQ applies the NEQ predicate on the "used_usdt" field.
func UsedUsdtNEQ(v float64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUsedUsdt), v))
	})
}

// UsedUsdtIn applies the In predicate on the "used_usdt" field.
func UsedUsdtIn(vs ...float64) predicate.UserBuyRecord {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUsedUsdt), v...))
	})
}

// UsedUsdtNotIn applies the NotIn predicate on the "used_usdt" field.
func UsedUsdtNotIn(vs ...float64) predicate.UserBuyRecord {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUsedUsdt), v...))
	})
}

// UsedUsdtGT applies the GT predicate on the "used_usdt" field.
func UsedUsdtGT(v float64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUsedUsdt), v))
	})
}

// UsedUsdtGTE applies the GTE predicate on the "used_usdt" field.
func UsedUsdtGTE(v float64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUsedUsdt), v))
	})
}

// UsedUsdtLT applies the LT predicate on the "used_usdt" field.
func UsedUsdtLT(v float64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUsedUsdt), v))
	})
}

// UsedUsdtLTE applies the LTE predicate on the "used_usdt" field.
func UsedUsdtLTE(v float64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUsedUsdt), v))
	})
}

// BuyDateEQ applies the EQ predicate on the "buy_date" field.
func BuyDateEQ(v string) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBuyDate), v))
	})
}

// BuyDateNEQ applies the NEQ predicate on the "buy_date" field.
func BuyDateNEQ(v string) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBuyDate), v))
	})
}

// BuyDateIn applies the In predicate on the "buy_date" field.
func BuyDateIn(vs ...string) predicate.UserBuyRecord {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldBuyDate), v...))
	})
}

// BuyDateNotIn applies the NotIn predicate on the "buy_date" field.
func BuyDateNotIn(vs ...string) predicate.UserBuyRecord {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldBuyDate), v...))
	})
}

// BuyDateGT applies the GT predicate on the "buy_date" field.
func BuyDateGT(v string) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldBuyDate), v))
	})
}

// BuyDateGTE applies the GTE predicate on the "buy_date" field.
func BuyDateGTE(v string) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldBuyDate), v))
	})
}

// BuyDateLT applies the LT predicate on the "buy_date" field.
func BuyDateLT(v string) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldBuyDate), v))
	})
}

// BuyDateLTE applies the LTE predicate on the "buy_date" field.
func BuyDateLTE(v string) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldBuyDate), v))
	})
}

// BuyDateContains applies the Contains predicate on the "buy_date" field.
func BuyDateContains(v string) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldBuyDate), v))
	})
}

// BuyDateHasPrefix applies the HasPrefix predicate on the "buy_date" field.
func BuyDateHasPrefix(v string) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldBuyDate), v))
	})
}

// BuyDateHasSuffix applies the HasSuffix predicate on the "buy_date" field.
func BuyDateHasSuffix(v string) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldBuyDate), v))
	})
}

// BuyDateEqualFold applies the EqualFold predicate on the "buy_date" field.
func BuyDateEqualFold(v string) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldBuyDate), v))
	})
}

// BuyDateContainsFold applies the ContainsFold predicate on the "buy_date" field.
func BuyDateContainsFold(v string) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldBuyDate), v))
	})
}

// CreatedEQ applies the EQ predicate on the "created" field.
func CreatedEQ(v int64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreated), v))
	})
}

// CreatedNEQ applies the NEQ predicate on the "created" field.
func CreatedNEQ(v int64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCreated), v))
	})
}

// CreatedIn applies the In predicate on the "created" field.
func CreatedIn(vs ...int64) predicate.UserBuyRecord {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCreated), v...))
	})
}

// CreatedNotIn applies the NotIn predicate on the "created" field.
func CreatedNotIn(vs ...int64) predicate.UserBuyRecord {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCreated), v...))
	})
}

// CreatedGT applies the GT predicate on the "created" field.
func CreatedGT(v int64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCreated), v))
	})
}

// CreatedGTE applies the GTE predicate on the "created" field.
func CreatedGTE(v int64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCreated), v))
	})
}

// CreatedLT applies the LT predicate on the "created" field.
func CreatedLT(v int64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCreated), v))
	})
}

// CreatedLTE applies the LTE predicate on the "created" field.
func CreatedLTE(v int64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCreated), v))
	})
}

// UpdatedEQ applies the EQ predicate on the "updated" field.
func UpdatedEQ(v int64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdated), v))
	})
}

// UpdatedNEQ applies the NEQ predicate on the "updated" field.
func UpdatedNEQ(v int64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpdated), v))
	})
}

// UpdatedIn applies the In predicate on the "updated" field.
func UpdatedIn(vs ...int64) predicate.UserBuyRecord {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpdated), v...))
	})
}

// UpdatedNotIn applies the NotIn predicate on the "updated" field.
func UpdatedNotIn(vs ...int64) predicate.UserBuyRecord {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpdated), v...))
	})
}

// UpdatedGT applies the GT predicate on the "updated" field.
func UpdatedGT(v int64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpdated), v))
	})
}

// UpdatedGTE applies the GTE predicate on the "updated" field.
func UpdatedGTE(v int64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpdated), v))
	})
}

// UpdatedLT applies the LT predicate on the "updated" field.
func UpdatedLT(v int64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpdated), v))
	})
}

// UpdatedLTE applies the LTE predicate on the "updated" field.
func UpdatedLTE(v int64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpdated), v))
	})
}

// DeletedEQ applies the EQ predicate on the "deleted" field.
func DeletedEQ(v int64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDeleted), v))
	})
}

// DeletedNEQ applies the NEQ predicate on the "deleted" field.
func DeletedNEQ(v int64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDeleted), v))
	})
}

// DeletedIn applies the In predicate on the "deleted" field.
func DeletedIn(vs ...int64) predicate.UserBuyRecord {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDeleted), v...))
	})
}

// DeletedNotIn applies the NotIn predicate on the "deleted" field.
func DeletedNotIn(vs ...int64) predicate.UserBuyRecord {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDeleted), v...))
	})
}

// DeletedGT applies the GT predicate on the "deleted" field.
func DeletedGT(v int64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDeleted), v))
	})
}

// DeletedGTE applies the GTE predicate on the "deleted" field.
func DeletedGTE(v int64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDeleted), v))
	})
}

// DeletedLT applies the LT predicate on the "deleted" field.
func DeletedLT(v int64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDeleted), v))
	})
}

// DeletedLTE applies the LTE predicate on the "deleted" field.
func DeletedLTE(v int64) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDeleted), v))
	})
}

// HasOwner applies the HasEdge predicate on the "owner" edge.
func HasOwner() predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(OwnerTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, OwnerTable, OwnerColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasOwnerWith applies the HasEdge predicate on the "owner" edge with a given conditions (other predicates).
func HasOwnerWith(preds ...predicate.User) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(OwnerInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, OwnerTable, OwnerColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.UserBuyRecord) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.UserBuyRecord) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.UserBuyRecord) predicate.UserBuyRecord {
	return predicate.UserBuyRecord(func(s *sql.Selector) {
		p(s.Not())
	})
}
